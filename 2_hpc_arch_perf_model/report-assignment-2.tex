\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,
            bindingoffset=0.2in,
            left=1in,
            right=1in,
            top=1in,
            bottom=1in,
            footskip=.25in]{geometry}

%###############################################################################

%\input{~/layout/global_layout}


%###############################################################################

% packages begin

\usepackage[
  backend=biber,
  sortcites=true,
  style=alphabetic,
  eprint=true,
  backref=true
]{biblatex}
\addbibresource{bibliographie.bib}
\usepackage[acronym]{glossaries}

\usepackage{euscript}[mathcal]
% e.g. \mathcal{A} for fancy letters in mathmode
\usepackage{amsmath,amssymb,amstext,amsthm}

\usepackage{mdframed}
\newmdtheoremenv[nobreak=true]{problem}{Problem}[subsection]
\newmdtheoremenv[nobreak=true]{claim}{Claim}[subsection]
\newtheorem{definition}{Definition}[subsection]
\newtheorem{lemma}{Lemma}[claim]
\newtheorem{plemma}{Lemma}[problem]

\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage{enumerate}
\usepackage[pdftex]{graphicx}
\usepackage{subcaption}
% 'draft' für schnelleres rendern mitübergeben -> [pdftex, draft]
% dadruch wird nicht das bild mitgerendered, sondern nur ein kasten mit bildname -> schont ressourcen

\usepackage{hyperref}

\usepackage{tikz}
\usetikzlibrary{arrows,automata,matrix,positioning,shapes}

% for adding non-formatted text to include source-code
\usepackage{listings}
\lstset{language=Python,basicstyle=\footnotesize}
% z.B.:
% \lstinputlisting{source_filename.py}
% \lstinputlisting[lanugage=Python, firstline=37, lastline=45]{source_filename.py}
%
% oder
%
% \begin{lstlisting}[frame=single]
% CODE HERE
%\end{lstlisting}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{wasysym}

\usepackage{titling}
\usepackage{titlesec}
\usepackage[nocheck]{fancyhdr}
\usepackage{lastpage}

\usepackage{kantlipsum}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

% packages end
%###############################################################################

\pretitle{% add some rules
  \begin{center}
    \LARGE\bfseries
} %, make the fonts bigger, make the title (only) bold
\posttitle{%
  \end{center}%
  %\vskip .75em plus .25em minus .25em% increase the vertical spacing a bit, make this particular glue stretchier
}
\predate{%
  \begin{center}
    \normalsize
}
\postdate{%
  \end{center}%
}

\titleformat*{\section}{\Large\bfseries}
\titleformat*{\subsection}{\large\bfseries}
\titleformat*{\subsubsection}{\normalsize\bfseries}

\titleformat*{\paragraph}{\Large\bfseries}
\titleformat*{\subparagraph}{\large\bfseries}

%###############################################################################

\pagestyle{fancy}
\fancyhf{}
% l=left, c=center, r=right; e=even_pagenumber, o=odd_pagenumber; h=header, f=footer
% example: [lh] -> left header, [lof,ref] -> fotter left when odd, right when even
%\fancyhf[lh]{}
%\fancyhf[ch]{}
%\fancyhf[rh]{}
%\fancyhf[lf]{}
\fancyhf[cf]{\footnotesize Page \thepage\ of \pageref*{LastPage}}
%\fancyhf[rf]{}
\renewcommand{\headrule}{} % removes horizontal header line

% Fotter options for first page

\fancypagestyle{firstpagestyle}{
  \renewcommand{\thedate}{\textmd{}} % removes horizontal header line
  \fancyhf{}
  \fancyhf[lh]{\ttfamily M.Sc. Computer Science\\KTH Royal Institute of Technology}
  \fancyhf[rh]{\ttfamily Period 4\\\today}
  \fancyfoot[C]{\footnotesize Page \thepage\ of \pageref*{LastPage}}
  \renewcommand{\headrule}{} % removes horizontal header line
}
%###############################################################################

\newcommand\extrafootertext[1]{%
    \bgroup
    \renewcommand\thefootnote{\fnsymbol{footnote}}%
    \renewcommand\thempfootnote{\fnsymbol{mpfootnote}}%
    \footnotetext[0]{#1}%
    \egroup
}

%###############################################################################

\title{
  \normalsize{DD2356 VT25 Methods in}\\
  \normalsize{High Performance Computing}\\
  \large{Assignment 2}
}
\author{
  \small Rishi Vijayvargiya\textsuperscript{\textdagger}\\[-0.75ex]
%  \footnotesize\texttt{MN: }\\[-1ex]
  \scriptsize\texttt{rishiv@kth.se}
  \and
  \small Paul Mayer\textsuperscript{\textdagger}\\[-0.75ex]
%  \footnotesize\texttt{MN: }\\[-1ex]
  \scriptsize\texttt{pmayer@kth.se}
  \and
  \small Lennard Herud \textsuperscript{\textdagger}\\[-0.75ex]
%  \footnotesize\texttt{MN: }\\[-1ex]
  \scriptsize\texttt{herud@kth.se}
}
\date{}

%###############################################################################
% define Commands

\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\I}{\mathbb{I}}

\newcommand{\E}{\mathbb{E}}
\newcommand{\Prob}{\mathbb{P}}

\renewcommand{\epsilon}{\varepsilon}

%###############################################################################
\makeatletter
\renewcommand*{\@fnsymbol}[1]{\ensuremath{\ifcase#1\or \dagger\or \ddagger\or
   \mathsection\or \mathparagraph\or \|\or **\or \dagger\dagger
   \or \ddagger\ddagger \else\@ctrerr\fi}}
\makeatother
%###############################################################################

\begin{document}
\maketitle
\extrafootertext{\textsuperscript{\textdagger}Authors made equal contribution to the project}
\thispagestyle{firstpagestyle}

\listoftodos
\vspace{1em}

% content begin
%

\section*{Prefix}
The code for our project can be found at this location: \url{https://github.com/paulmyr/DD2356-MethodsHPC/tree/master/2_hpc_arch_perf_model}. 

\tableofcontents
\newpage


\section{}
\todo[inline]{Check headers}



\section{Exercise 1: Supercomputer Architecture with hwloc}

\section{Exercise 2: Roofline Model}
\todo{How to build the roofline model? What should the array size in stream benchmark be? Using 200mil causes errors during compilation. The default size seems too small according to comments in the code}
\todo{How to establish the peak compute using the information of the processor?}

\section{Exercise 3: Modeling Sparse Matrix-Vector Multiply}

\section{Exercise 4: Measure the Performance with Perf}
\subsection{Matrix Multiply}
We created files \verb|matrix_multiply.c| and \verb|matrix_multiply_opt.c|, which were the default and optimized versions of the algorithm provided, respectively. We used the follogin \verb|salloc| command to allocate resources: 

\begin{lstlisting}[language=bash,basicstyle=\ttfamily]
salloc -t 00:30:00 --nodes 1  -A edu25.DD2356 -p shared
\end{lstlisting}
Since no \verb|--cpus-per-task| argument was provided, we believe that the default value of 1 was used. Additionally, since no \verb|-n| flag was provided either, we believe that the code was execute on 1 core. 

Compiling using the provided commands, then executed \verb|perf| using the following command: 
\begin{lstlisting}[language=bash,basicstyle=\tiny\ttfamily]
srun -n 1 perf stat -e instructions,cycles,L1-dcache-load-misses,L1-dcache-loads ./matrix_multiply.out
\end{lstlisting}
The same thing was done for the optimized version. We varied \verb|MSIZE| manually, recompiled, and then re-executed the commands above for the different \verb|MSIZE| values. 
Doing so, we obtained the following table (for \textit{Elapsed time}, we record the values obtained from \verb|perf| and not the one produced by the algorithm) 
\begin{table}[h!]
\centering
\begin{tabular}{|c|p{2.5cm}|p{2.5cm}|p{2.5cm}|p{2.5cm}|}
\hline
\textbf{Event Name} & \textbf{Naive (MSIZE 64)} & \textbf{Optimized (MSIZE 64)} & \textbf{Naive (MSIZE 1000)} & \textbf{Optimized (MSIZE 1000)} \\
\hline
\textbf{Elapsed time (sec)} & 0.008982713 & 0.008476052 & 17.968526050 & 1.685069089 \\
\hline
\textbf{Instructions per cycle} & 1.16 & 1.28 & 0.58 & 2.17 \\
\hline
\textbf{L1 cache miss ratio} & 0.1817 & 0.0610 & 0.5618 & 0.1649 \\
\hline
\textbf{L1 cache miss rate PTI} & 101.5736 & 26.5007 & 400.6424 & 131.9917  \\
\hline
\end{tabular}
\caption{Perf Stats for Default and Optimized Matrix-Multiply}
\end{table}
The raw outputs for the different values of \verb|MSIZE| for the \verb|matrix_multiply.out| and \verb|matrix_multiply_opt.out| binaries can be found in the file \verb|matrix_multiply_outputs.txt| in the repository \href{https://github.com/paulmyr/DD2356-MethodsHPC/blob/master/2_hpc_arch_perf_model/exercise4/matrix_multiply_outputs.txt}{here}. For the \verb|L1 cache miss ratio| and the \verb|L1 cache miss rate PTI|, we used the formulas \href{https://canvas.kth.se/courses/53216/pages/tutorial-the-perf-tool?module_item_id=1067474}{here}.

\todo{Answer the question for this section}

\subsection{Matrix Transpose}
We created the file \verb|transpose.c| and compiled the program into 3 different binaries using the following command: 
\begin{lstlisting}[language=bash,basicstyle=\ttfamily]
cc -O2 -o transpose_n{grid_size}.out transpose.c
\end{lstlisting}
Here, the \verb|grid_size| depended on the size of \verb|N| required in the handout. Thus, it varied from 64 to 128 to 2048. 

We allocated compute nodes using the same \verb|salloc| command described for matrix multiplication. Finally, we ran each of the compiled binaries using the following \verb|srun| command: 
\begin{lstlisting}[language=bash,basicstyle=\tiny\ttfamily]
srun -n 1 perf stat -e instructions,cycles,L1-dcache-load-misses,L1-dcache-loads ./transpose_n{grid_size}.out
\end{lstlisting}
With this, we obtained the following outputs (\textit{Elapsed time} was recorded based on the output in \verb|perf|, not on the one produced by the program)
\begin{table}[h!]
\centering
\begin{tabular}{|c|p{2.5cm}|p{2.5cm}|p{2.5cm}|}
\hline
\textbf{Event Name} & \textbf{N 64} & \textbf{N 128} & \textbf{N 2048}  \\
\hline
\textbf{Elapsed time (sec)} & 0.040026827 & 0.008985869 & 35.493702241  \\
\hline
\textbf{Bandwidth / Rate} & 2.50e+04 MB/s & 6.94e+03 MB/s & 9.48e+01 MB/s \\
\hline
\textbf{Instructions per cycle} & 1.38 & 0.91 & 0.01 \\ 
\hline
\textbf{L1 cache miss ratio} & 0.0509 & 0.1683 & 0.2033 \\
\hline
\textbf{L1 cache miss rate PTI} & 23.7404 & 175.4544 & 3351.8774  \\
\hline
\end{tabular}
\caption{Perf Stats for Default and Optimized Matrix-Multiply}
\end{table}



\todo{Answer the questions for this section}

\section{Bonus: Network Latency \& Bandwidth Analysis with MPI Ping-Pong}
\subsection{Modifications to the Code}
There were some issues encountered in the provided code for \verb|mpi_ping_pong.c| file. 
\begin{itemize}
\item \verb|d| to \verb|lu| conversion when printing bytes: The original code gave a warning when compiled using \verb|cc mpi_ping_pong.c -o mpi_ping_pong|. \\
\item \verb|fflush(stdout)| immediately after printing information: As highlighted in the \href{https://canvas.kth.se/courses/53216/discussion_topics/456480}{discussion forum}, the code did not seem to terminate. Thus, adding \verb|fflush| statements after \verb|printf|s ensured that we get the output in this case. \textit{(Note: There was an answer provided by a student w.r.t modifying the code to ensure termination, but that did not seem to resolve the issue either. The student provided their entire modified code in the follow-up, but we did not use that version as we weren't sure if that matched with the semantics of the original code. Thus, we are not reporting the runtimes of the student-modified code here)}. 
\end{itemize}
The modified file can be found \href{https://github.com/paulmyr/DD2356-MethodsHPC/blob/master/2_hpc_arch_perf_model/bonus/mpi_ping_pong.c}{here}.

\subsection{Compiling, Allocating Nodes, and Running}
We allocated 2 different nodes, with 1 task per node, using the following command: 
\begin{lstlisting}[language=bash,basicstyle=\tiny\ttfamily]
salloc -t 00:30:00 --nodes 2 --ntasks-per-node 1 --cpus-per-task 1 -A edu25.DD2356 -p shared 
\end{lstlisting}
For compiling the file, we used the following command mentioned earlier: 
\begin{lstlisting}[language=bash,basicstyle=\ttfamily]
cc mpi_ping_pong.c -o mpi_ping_pong
\end{lstlisting}
Finally, to run the program, we used the following command provided in the handout: 
\begin{lstlisting}[language=bash,basicstyle=\ttfamily]
srun -N2 --ntasks=2 ./mpi_ping_pong
\end{lstlisting}

\subsection{Results}
The default code in \verb| only allowed \verb|size| to be atmost 1024 in the main loop. With this confirguration, apart from the very first send-receive interaction, the RTT for the other interactions seems to be relatively constant.

\todo{insert graph}

We believe that the first interaction has a very high RTT because of the time required to setup the initial infrastructure that will be used for the rest of the communication. On the recommendation of Professor Peng, we increased the \verb|size| limit to see some increase in the RTT to 65536 instead of 1024. With this setup, however, we started receiving segmentation faults after 16384 bytes (in one run, this was after 32768 bytes). This means that after \verb|size| reaches $32768 / 4 = 4096$ (since the printed size is multiplied with 4), there seems to be an error with the code which causes a segmentation fault. 

We did not attempt to spend time fixing the issue as we haven't yet been introduced to MPI in the course and because we did not wish to change the semantics of the original code. However, even with the output that was produced, we were able to see a gradual increasing trend in RTT as the size increases, as illustrated in the graph below. 

\todo{insert graph}

The textual outputs for the 2 runs plotted above can be found in the 

\todo{The output is a bit flat for the provided sizes. Increasing ths size (to about 16384) causes segmentation fault at different points in time}
\todo{Submit with these annotations or try and "fix" the problem}

% content end
%###############################################################################

% \printbibliography

\end{document}